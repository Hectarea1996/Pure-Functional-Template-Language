#ifndef INT_TYPE_H_INCLUDED
#define INT_TYPE_H_INCLUDED

#include "curry.h"
#include "eq_type.h"
#include "ord_type.h"
#include "enum_type.h"
#include "num_type.h"
#include "integral_type.h"
#include "integral_nt.h"
#include "list_type.h"

namespace pftl{

//********************************************************************************
//--------------------------------------------------------------------------------

template<bool b>
struct Bool;

//--------------------------------------------------------------------------------
//********************************************************************************

//********************************************************************************
//--------------------------------------------------------------------------------

struct Int_t{};

//********************************************************************************

template<int x>
struct Int : virtual Int_t{};

//--------------------------------------------------------------------------------
//********************************************************************************

//********************************************************************************
//--------------------------------------------------------------------------------

template<class I, class J>
struct eq_Int{};

//--------------------------------------------------------------------------------

template<int k>
struct Eq_c<Int<k>>{
    template<class I>
    using eq = typename eq_Int<Int<k>,I>::value;
};

//--------------------------------------------------------------------------------

template<int k, int l>
struct eq_Int<Int<k>,Int<l>>{
    using value = Bool<k==l>;
};

//--------------------------------------------------------------------------------
//********************************************************************************

//********************************************************************************
//--------------------------------------------------------------------------------

template<class I, class J>
struct le_Int{};

//--------------------------------------------------------------------------------

template<int k>
struct Ord_c<Int<k>>{
    template<class I>
    using le = typename le_Int<Int<k>,I>::value;
};

//--------------------------------------------------------------------------------

template<int k, int l>
struct le_Int<Int<k>,Int<l>>{
    using value = Bool<(k<=l)>;
};

//--------------------------------------------------------------------------------
//********************************************************************************

//********************************************************************************
//--------------------------------------------------------------------------------

template<int k>
struct Enum_c<Int<k>>{

    using succ = Int<k+1>;

    using pred = Int<k-1>;

};

//--------------------------------------------------------------------------------
//********************************************************************************

//********************************************************************************
//--------------------------------------------------------------------------------

template<class I, class J>
struct plus_Int{};

template<class I, class J>
struct minus_Int{};

template<class I, class J>
struct mult_Int{};

//--------------------------------------------------------------------------------

template<int k>
struct Num_c<Int<k>>{

    template<class I>
    using plus = typename plus_Int<Int<k>,I>::value;

    template<class I>
    using minus = typename minus_Int<Int<k>,I>::value;

    template<class I>
    using mult = typename mult_Int<Int<k>,I>::value;

    using negate = Int<-k>;

    using abs = Int<abs_nt::let<k>>;

    using signum = Int<signum_nt::let<k>>;

};

//--------------------------------------------------------------------------------

template<int k, int l>
struct plus_Int<Int<k>,Int<l>>{
    using value = Int<k+l>;
};

template<int k, int l>
struct minus_Int<Int<k>,Int<l>>{
    using value = Int<k-l>;
};

template<int k, int l>
struct mult_Int<Int<k>,Int<l>>{
    using value = Int<k*l>;
};

//--------------------------------------------------------------------------------
//********************************************************************************

//********************************************************************************
//--------------------------------------------------------------------------------

template<class I, class J>
struct div_Int{};

template<class I, class J>
struct mod_Int{};

//--------------------------------------------------------------------------------

template<int k>
struct Integral_c<Int<k>>{

    template<class I>
    using div = Int<k+1>;

    template<class I>
    using mod = Int<k-1>;

};

//--------------------------------------------------------------------------------

template<int k, int l>
struct div_Int<Int<k>,Int<l>>{
    using value = Int<k/l>;
};

template<int k, int l>
struct mod_Int<Int<k>,Int<l>>{
    using value = Int<k%l>;
};

//--------------------------------------------------------------------------------
//********************************************************************************

//********************************************************************************
//--------------------------------------------------------------------------------

template<class I>
struct show_Int{};

//--------------------------------------------------------------------------------

template<int k>
struct Show_c<Int<k>>{

    using show = Int<k+1>;

};

//--------------------------------------------------------------------------------

template<int x>
struct show_IntAux{
    using value = typename concat::let<typename show_IntAux<x/10>::value>::template let<List<Char<(char)(x%10+'0')>>>;
};

template<>
struct show_IntAux<0>{
    using value = List<>;
};

template<int x>
struct show_Int<Int<x>>{
    using value = typename concat::let<typename show_IntAux<x/10>::value>::template let<List<Char<(char)(x%10+'0')>>>;
};

//--------------------------------------------------------------------------------
//********************************************************************************

//********************************************************************************
//--------------------------------------------------------------------------------

template<int x>
struct toType_impl<x>{
    using value = Int<x>;
};

template<int x>
struct toNonType_impl<Int<x>>{
    static const int value = x;
};

//--------------------------------------------------------------------------------
//********************************************************************************

}

#endif // INT_TYPE_H_INCLUDED
